// const variablename=require(packagename) - syntax to import the package
const express = require("express")
const cors = require("cors")
const bodyparser = require("body-parser")
const mysql = require("mysql")
const multer = require("multer")
const path = require("path")
const jwt = require("jsonwebtoken")

// const variablename=package variablename into function using ()
const connect = express()

// connect the other packages with express by using use keyword
connect.use(cors())
connect.use(bodyparser.json())
connect.use(express.json())
connect.use(express.static('public'))
connect.use(bodyparser.urlencoded({extended:true}))

// let variablename=mysql variable name . createConnection predef func()
// inside createConnection 5 values are added into the function that differs to person to person
let databaseconnection = mysql.createConnection({
    host: "localhost",
    port: 3306,
    user: "root",
    password: "N@ndhu0514",
    database: "ecommerce_db"
})

// to check whether db connected to BE, the connect keyword here is a predef func of mysql which is not related to express method.
databaseconnection.connect(function(error){
    if(error){
        console.log(error)
    }
    else{
        console.log("database connected")
    }
})

// multer setup to handle image uploads
const storage = multer.diskStorage({
    destination: './upload/images',
    filename: (request, file, callback) => {
        callback(null, `${file.fieldname}_${Date.now()}${path.extname(file.originalname)}`)
    }
})
const upload = multer({ storage: storage })

// to serve uploaded images to FE
connect.use('/images', express.static('upload/images'))

// image upload endpoint
connect.post('/upload', upload.single('product'), (request, response) => {
    response.json({
        success: 1,
        image_url: `http://localhost:3002/images/${request.file.filename}`
    })
})

// add product to database
connect.post('/addproduct', (request, response) => {
    let { name, image, category, new_price, old_price } = request.body
    let sql = 'SELECT MAX(id) AS maxId FROM products'

    databaseconnection.query(sql, (error, result) => {
        if(error){
            response.send(error)
        }
        else{
            let id = result[0].maxId ? result[0].maxId + 1 : 1
            let insert = 'INSERT INTO products(id, name, image, category, new_price, old_price, date, available) VALUES (?, ?, ?, ?, ?, ?, NOW(), true)'
            databaseconnection.query(insert, [id, name, image, category, new_price, old_price], (error2, result2) => {
                if(error2){
                    response.send(error2)
                }
                else{
                    response.send({ success: true, name })
                }
            })
        }
    })
})

// remove product from database
connect.post('/removeproduct', (request, response) => {
    let { id } = request.body
    let sql = 'DELETE FROM products WHERE id = ?'
    databaseconnection.query(sql, [id], (error, result) => {
        if(error){
            response.send(error)
        }
        else{
            response.send({ success: true })
        }
    })
})

// get all products
connect.get('/allproducts', (request, response) => {
    let sql = 'SELECT * FROM products'
    databaseconnection.query(sql, (error, result) => {
        if(error){
            response.send(error)
        }
        else{
            response.send(result)
        }
    })
})

// signup endpoint
connect.post('/signup', (request, response) => {
    let { name, email, password } = request.body
    let sql = 'SELECT * FROM users WHERE email = ?'
    databaseconnection.query(sql, [email], (error, result) => {
        if(error){
            response.send(error)
        }
        else if(result.length > 0){
            response.send({ success: false, errors: "Existing user found with same email address" })
        }
        else{
            let cart = {}
            for(let i = 0; i < 300; i++){
                cart[i] = 0
            }
            let insert = 'INSERT INTO users(name, email, password, cartData, date) VALUES (?, ?, ?, ?, NOW())'
            databaseconnection.query(insert, [name, email, password, JSON.stringify(cart)], (error2, result2) => {
                if(error2){
                    response.send(error2)
                }
                else{
                    let data = { user: { id: result2.insertId } }
                    let token = jwt.sign(data, 'secret_ecom')
                    response.send({ success: true, token })
                }
            })
        }
    })
})

// login endpoint
connect.post('/login', (request, response) => {
    let { email, password } = request.body
    let sql = 'SELECT * FROM users WHERE email = ?'
    databaseconnection.query(sql, [email], (error, result) => {
        if(error){
            response.send(error)
        }
        else if(result.length === 0){
            response.send({ success: false, errors: "Wrong Email Id" })
        }
        else{
            let user = result[0]
            if(user.password === password){
                let data = { user: { id: user.id } }
                let token = jwt.sign(data, 'secret_ecom')
                response.send({ success: true, token })
            }
            else{
                response.send({ success: false, errors: "Wrong Password" })
            }
        }
    })
})

// middleware to verify token
const fetchUser = (request, response, next) => {
    const token = request.header('auth-token')
    if(!token){
        response.status(401).send({ errors: "Please authenticate using a valid token" })
    }
    else{
        try{
            const data = jwt.verify(token, 'secret_ecom')
            request.user = data.user
            next()
        }
        catch{
            response.status(401).send({ errors: "Please authenticate using a valid token" })
        }
    }
}

// add to cart
connect.post('/addtocart', fetchUser, (request, response) => {
    let { itemId } = request.body
    let sql = 'SELECT cartData FROM users WHERE id = ?'
    databaseconnection.query(sql, [request.user.id], (error, result) => {
        if(error){
            response.send(error)
        }
        else{
            let cart = JSON.parse(result[0].cartData)
            cart[itemId] = (cart[itemId] || 0) + 1
            let update = 'UPDATE users SET cartData = ? WHERE id = ?'
            databaseconnection.query(update, [JSON.stringify(cart), request.user.id], (error2) => {
                if(error2){
                    response.send(error2)
                }
                else{
                    response.send({ success: true })
                }
            })
        }
    })
})

// remove from cart
connect.post('/removefromcart', fetchUser, (request, response) => {
    let { itemId } = request.body
    let sql = 'SELECT cartData FROM users WHERE id = ?'
    databaseconnection.query(sql, [request.user.id], (error, result) => {
        if(error){
            response.send(error)
        }
        else{
            let cart = JSON.parse(result[0].cartData)
            if(cart[itemId] > 0){
                cart[itemId] -= 1
            }
            let update = 'UPDATE users SET cartData = ? WHERE id = ?'
            databaseconnection.query(update, [JSON.stringify(cart), request.user.id], (error2) => {
                if(error2){
                    response.send(error2)
                }
                else{
                    response.send({ success: true })
                }
            })
        }
    })
})

// get cart data
connect.post('/getcart', fetchUser, (request, response) => {
    let sql = 'SELECT cartData FROM users WHERE id = ?'
    databaseconnection.query(sql, [request.user.id], (error, result) => {
        if(error){
            response.send(error)
        }
        else{
            response.send(JSON.parse(result[0].cartData))
        }
    })
})

// get new collections
connect.get('/newcollections', (request, response) => {
    let sql = 'SELECT * FROM products ORDER BY date DESC LIMIT 8 OFFSET 1'
    databaseconnection.query(sql, (error, result) => {
        if(error){
            response.send(error)
        }
        else{
            response.send(result)
        }
    })
})

// get popular products
connect.get('/popular', (request, response) => {
    let sql = 'SELECT * FROM products ORDER BY date DESC LIMIT 4'
    databaseconnection.query(sql, (error, result) => {
        if(error){
            response.send(error)
        }
        else{
            response.send(result)
        }
    })
})

// to check the database connection through server similar to React
// connect here is express method, listen should always be at end.
connect.listen(3002, () => {
    console.log("your server is running in port 3002")
})












// import express from "express";
// import cors from "cors";
// import multer from "multer";
// import path from "path";
// import jwt from "jsonwebtoken";
// import mysql from "mysql2/promise";

// const app = express();
// const port = 5000;

// app.use(express.json());
// app.use(cors());

// // MySQL connection
// const db = await mysql.createConnection({
//   host: "localhost",
//   user: "root",
//   password: "1qaz2wsx",
//   database: "ecommerce_db"
// });

// // Multer setup
// const storage = multer.diskStorage({
//   destination: './upload/images',
//   filename: (req, file, cb) => {
//     cb(null, `${file.fieldname}_${Date.now()}${path.extname(file.originalname)}`);
//   }
// });
// const upload = multer({ storage });
// app.use('/images', express.static('upload/images'));

// // Routes
// app.get("/", (req, res) => {
//   res.send("Express App is Running");
// });

// app.post("/upload", upload.single('product'), (req, res) => {
//   res.json({
//     success: 1,
//     image_url: `http://localhost:${port}/images/${req.file.filename}`
//   });
// });

// // Add product
// app.post("/addproduct", async (req, res) => {
//   const [rows] = await db.query("SELECT MAX(id) AS maxId FROM products");
//   const id = rows[0].maxId ? rows[0].maxId + 1 : 1;

//   const { name, image, category, new_price, old_price } = req.body;
//   await db.query(
//     "INSERT INTO products (id, name, image, category, new_price, old_price, available) VALUES (?, ?, ?, ?, ?, ?, ?)",
//     [id, name, image, category, new_price, old_price, true]
//   );

//   res.json({ success: true, name });
// });

// // Remove product
// app.post("/removeproduct", async (req, res) => {
//   await db.query("DELETE FROM products WHERE id = ?", [req.body.id]);
//   res.json({ success: true });
// });

// // Get all products
// app.get("/allproducts", async (req, res) => {
//   const [products] = await db.query("SELECT * FROM products");
//   res.send(products);
// });

// // Signup
// app.post("/signup", async (req, res) => {
//   const { name, email, password } = req.body;
//   const [existing] = await db.query("SELECT * FROM users WHERE email = ?", [email]);

//   if (existing.length > 0) {
//     return res.status(400).json({ success: false, errors: "Email already exists" });
//   }

//   const cartData = JSON.stringify(Object.fromEntries(Array.from({ length: 300 }, (_, i) => [i, 0])));
//   await db.query("INSERT INTO users (name, email, password, cartData) VALUES (?, ?, ?, ?)", [name, email, password, cartData]);

//   const [user] = await db.query("SELECT id FROM users WHERE email = ?", [email]);
//   const token = jwt.sign({ user: { id: user[0].id } }, "secret_ecom");
//   res.json({ success: true, token });
// });

// // Login
// app.post("/login", async (req, res) => {
//   const { email, password } = req.body;
//   const [user] = await db.query("SELECT * FROM users WHERE email = ?", [email]);

//   if (user.length === 0) return res.json({ success: false, errors: "Wrong Email Id" });
//   if (user[0].password !== password) return res.json({ success: false, errors: "Wrong Password" });

//   const token = jwt.sign({ user: { id: user[0].id } }, "secret_ecom");
//   res.json({ success: true, token });
// });

// // Auth middleware
// const fetchUser = async (req, res, next) => {
//   const token = req.header("auth-token");
//   if (!token) return res.status(401).send({ errors: "Please authenticate using a valid token" });

//   try {
//     const data = jwt.verify(token, "secret_ecom");
//     req.user = data.user;
//     next();
//   } catch {
//     res.status(401).send({ errors: "Invalid token" });
//   }
// };

// // Cart routes
// app.post("/addtocart", fetchUser, async (req, res) => {
//   const { itemId } = req.body;
//   const [user] = await db.query("SELECT cartData FROM users WHERE id = ?", [req.user.id]);
//   const cart = JSON.parse(user[0].cartData);
//   cart[itemId] = (cart[itemId] || 0) + 1;
//   await db.query("UPDATE users SET cartData = ? WHERE id = ?", [JSON.stringify(cart), req.user.id]);
//   res.send("Added");
// });

// app.post("/removefromcart", fetchUser, async (req, res) => {
//   const { itemId } = req.body;
//   const [user] = await db.query("SELECT cartData FROM users WHERE id = ?", [req.user.id]);
//   const cart = JSON.parse(user[0].cartData);
//   if (cart[itemId] > 0) cart[itemId] -= 1;
//   await db.query("UPDATE users SET cartData = ? WHERE id = ?", [JSON.stringify(cart), req.user.id]);
//   res.send("Removed");
// });

// app.post("/getcart", fetchUser, async (req, res) => {
//   const [user] = await db.query("SELECT cartData FROM users WHERE id = ?", [req.user.id]);
//   res.json(JSON.parse(user[0].cartData));
// });

// // Collections
// app.get("/newcollections", async (req, res) => {
//   const [products] = await db.query("SELECT * FROM products ORDER BY date DESC LIMIT 8 OFFSET 1");
//   res.send(products);
// });

// app.get("/popular", async (req, res) => {
//   const [products] = await db.query("SELECT * FROM products ORDER BY date DESC LIMIT 4");
//   res.send(products);
// });

// app.get("/related", async (req, res) => {
//   const [products] = await db.query("SELECT * FROM products ORDER BY date DESC LIMIT 4");
//   res.send(products);
// });

// // Start server
// app.listen(port, () => {
//   console.log(`Server running on port ${port}`);
// });



